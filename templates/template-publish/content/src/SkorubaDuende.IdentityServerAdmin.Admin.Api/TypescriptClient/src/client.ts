//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class WebApiClientBase {
    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        const headers = new Headers(options.headers);
        headers.set("X-ANTI-CSRF", "1");

        return {
            ...options,
            headers,
        };
    }
}

export interface IApiResourcesClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcesApiDto>;

    post(apiResourceApi: ApiResourceApiDto): Promise<void>;

    put(apiResourceApi: ApiResourceApiDto): Promise<void>;

    canInsertApiResource(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertApiResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    get2(id: number): Promise<ApiResourceApiDto>;

    delete(id: number): Promise<void>;

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiSecretsApiDto>;

    postSecret(id: number, clientSecretApi: ApiSecretApiDto): Promise<ApiSecretApiDto>;

    getSecret(secretId: number): Promise<ApiSecretApiDto>;

    deleteSecret(secretId: number): Promise<void>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcePropertiesApiDto>;

    postProperty(id: number, apiPropertyApi: ApiResourcePropertyApiDto): Promise<ApiResourcePropertyApiDto>;

    getProperty(propertyId: number): Promise<ApiResourcePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class ApiResourcesClient extends WebApiClientBase implements IApiResourcesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcesApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiResourcesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcesApiDto>(null as any);
    }

    post(apiResourceApi: ApiResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    put(apiResourceApi: ApiResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertApiResource(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiResources/CanInsertApiResource?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiResource(_response);
        });
    }

    protected processCanInsertApiResource(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertApiResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiResources/CanInsertApiResourceProperty?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiResourceProperty(_response);
        });
    }

    protected processCanInsertApiResourceProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    get2(id: number): Promise<ApiResourceApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<ApiResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourceApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourceApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiSecretsApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Secrets?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecrets(_response);
        });
    }

    protected processGetSecrets(response: Response): Promise<ApiSecretsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiSecretsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretsApiDto>(null as any);
    }

    postSecret(id: number, clientSecretApi: ApiSecretApiDto): Promise<ApiSecretApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Secrets";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientSecretApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSecret(_response);
        });
    }

    protected processPostSecret(response: Response): Promise<ApiSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiSecretApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretApiDto>(null as any);
    }

    getSecret(secretId: number): Promise<ApiSecretApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new globalThis.Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecret(_response);
        });
    }

    protected processGetSecret(response: Response): Promise<ApiSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiSecretApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretApiDto>(null as any);
    }

    deleteSecret(secretId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new globalThis.Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSecret(_response);
        });
    }

    protected processDeleteSecret(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Properties?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<ApiResourcePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertiesApiDto>(null as any);
    }

    postProperty(id: number, apiPropertyApi: ApiResourcePropertyApiDto): Promise<ApiResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Properties";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiPropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ApiResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiResourcePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ApiResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ApiResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IApiScopesClient {

    getScopes(search: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiScopesApiDto>;

    postScope(apiScopeApi: ApiScopeApiDto): Promise<ApiScopeDto>;

    putScope(apiScopeApi: ApiScopeApiDto): Promise<void>;

    canInsertApiScope(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertApiScopeProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    getScope(id: number): Promise<ApiScopeApiDto>;

    deleteScope(id: number): Promise<void>;

    getScopeProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiScopePropertiesApiDto>;

    postProperty(id: number, apiScopePropertyApi: ApiScopePropertyApiDto): Promise<ApiScopePropertyApiDto>;

    getProperty(propertyId: number): Promise<ApiScopePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class ApiScopesClient extends WebApiClientBase implements IApiScopesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getScopes(search: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiScopesApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopes(_response);
        });
    }

    protected processGetScopes(response: Response): Promise<ApiScopesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopesApiDto>(null as any);
    }

    postScope(apiScopeApi: ApiScopeApiDto): Promise<ApiScopeDto> {
        let url_ = this.baseUrl + "/api/ApiScopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopeApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostScope(_response);
        });
    }

    protected processPostScope(response: Response): Promise<ApiScopeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiScopeDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopeDto>(null as any);
    }

    putScope(apiScopeApi: ApiScopeApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopeApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutScope(_response);
        });
    }

    protected processPutScope(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertApiScope(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiScopes/CanInsertApiScope?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiScope(_response);
        });
    }

    protected processCanInsertApiScope(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertApiScopeProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiScopes/CanInsertApiScopeProperty?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiScopeProperty(_response);
        });
    }

    protected processCanInsertApiScopeProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getScope(id: number): Promise<ApiScopeApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScope(_response);
        });
    }

    protected processGetScope(response: Response): Promise<ApiScopeApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopeApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopeApiDto>(null as any);
    }

    deleteScope(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteScope(_response);
        });
    }

    protected processDeleteScope(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getScopeProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiScopePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}/Properties?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopeProperties(_response);
        });
    }

    protected processGetScopeProperties(response: Response): Promise<ApiScopePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertiesApiDto>(null as any);
    }

    postProperty(id: number, apiScopePropertyApi: ApiScopePropertyApiDto): Promise<ApiScopePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}/Properties";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopePropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ApiScopePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiScopePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ApiScopePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ApiScopePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IClientsClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ClientsApiDto>;

    post(client: ClientApiDto): Promise<ClientApiDto>;

    put(client: ClientApiDto): Promise<void>;

    get2(id: number): Promise<ClientApiDto>;

    delete(id: number): Promise<void>;

    getAccessTokenTypes(): Promise<SelectItemDto[]>;

    getTokenExpirations(): Promise<SelectItemDto[]>;

    getTokenUsage(): Promise<SelectItemDto[]>;

    getProtocolTypes(): Promise<SelectItemDto[]>;

    getDPoPValidationModes(): Promise<SelectItemDto[]>;

    getScopes(scope: string | null | undefined, limit: number | undefined, excludeIdentityResources: boolean | undefined, excludeApiScopes: boolean | undefined): Promise<string[]>;

    getGrantTypes(grant: string | null | undefined, includeObsoleteGrants: boolean | undefined, limit: number | undefined): Promise<SelectItemDto[]>;

    getHashTypes(): Promise<SelectItemDto[]>;

    getSecretTypes(): Promise<SelectItemDto[]>;

    getStandardClaims(claim: string | null | undefined, limit: number | undefined): Promise<string[]>;

    getSigningAlgorithms(algorithm: string | null | undefined, limit: number | undefined): Promise<string[]>;

    canInsertClient(id: number | undefined, clientId: string | null | undefined, isCloned: boolean | undefined): Promise<boolean>;

    postClientClone(client: ClientCloneApiDto): Promise<ClientApiDto>;

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientSecretsApiDto>;

    postSecret(id: number, clientSecretApi: ClientSecretApiDto): Promise<ClientSecretApiDto>;

    getSecret(secretId: number): Promise<ClientSecretApiDto>;

    deleteSecret(secretId: number): Promise<void>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientPropertiesApiDto>;

    postProperty(id: number, clientPropertyApi: ClientPropertyApiDto): Promise<ClientPropertyApiDto>;

    getProperty(propertyId: number): Promise<ClientPropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;

    getClaims(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientClaimsApiDto>;

    postClaim(id: number, clientClaimApiDto: ClientClaimApiDto): Promise<ClientClaimApiDto>;

    getClaim(claimId: number): Promise<ClientClaimApiDto>;

    deleteClaim(claimId: number): Promise<FileResponse>;
}

export class ClientsClient extends WebApiClientBase implements IClientsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ClientsApiDto> {
        let url_ = this.baseUrl + "/api/Clients?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ClientsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientsApiDto>(null as any);
    }

    post(client: ClientApiDto): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    put(client: ClientApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    get2(id: number): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccessTokenTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetAccessTokenTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAccessTokenTypes(_response);
        });
    }

    protected processGetAccessTokenTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getTokenExpirations(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetTokenExpirations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTokenExpirations(_response);
        });
    }

    protected processGetTokenExpirations(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getTokenUsage(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetTokenUsage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTokenUsage(_response);
        });
    }

    protected processGetTokenUsage(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getProtocolTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetProtocolTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProtocolTypes(_response);
        });
    }

    protected processGetProtocolTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getDPoPValidationModes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetDPoPValidationModes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDPoPValidationModes(_response);
        });
    }

    protected processGetDPoPValidationModes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getScopes(scope: string | null | undefined, limit: number | undefined, excludeIdentityResources: boolean | undefined, excludeApiScopes: boolean | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetScopes?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (excludeIdentityResources === null)
            throw new globalThis.Error("The parameter 'excludeIdentityResources' cannot be null.");
        else if (excludeIdentityResources !== undefined)
            url_ += "excludeIdentityResources=" + encodeURIComponent("" + excludeIdentityResources) + "&";
        if (excludeApiScopes === null)
            throw new globalThis.Error("The parameter 'excludeApiScopes' cannot be null.");
        else if (excludeApiScopes !== undefined)
            url_ += "excludeApiScopes=" + encodeURIComponent("" + excludeApiScopes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopes(_response);
        });
    }

    protected processGetScopes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getGrantTypes(grant: string | null | undefined, includeObsoleteGrants: boolean | undefined, limit: number | undefined): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetGrantTypes?";
        if (grant !== undefined && grant !== null)
            url_ += "grant=" + encodeURIComponent("" + grant) + "&";
        if (includeObsoleteGrants === null)
            throw new globalThis.Error("The parameter 'includeObsoleteGrants' cannot be null.");
        else if (includeObsoleteGrants !== undefined)
            url_ += "includeObsoleteGrants=" + encodeURIComponent("" + includeObsoleteGrants) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGrantTypes(_response);
        });
    }

    protected processGetGrantTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getHashTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetHashTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHashTypes(_response);
        });
    }

    protected processGetHashTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getSecretTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetSecretTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecretTypes(_response);
        });
    }

    protected processGetSecretTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getStandardClaims(claim: string | null | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetStandardClaims?";
        if (claim !== undefined && claim !== null)
            url_ += "claim=" + encodeURIComponent("" + claim) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStandardClaims(_response);
        });
    }

    protected processGetStandardClaims(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getSigningAlgorithms(algorithm: string | null | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetSigningAlgorithms?";
        if (algorithm !== undefined && algorithm !== null)
            url_ += "algorithm=" + encodeURIComponent("" + algorithm) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSigningAlgorithms(_response);
        });
    }

    protected processGetSigningAlgorithms(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    canInsertClient(id: number | undefined, clientId: string | null | undefined, isCloned: boolean | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Clients/CanInsertClient?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (isCloned === null)
            throw new globalThis.Error("The parameter 'isCloned' cannot be null.");
        else if (isCloned !== undefined)
            url_ += "isCloned=" + encodeURIComponent("" + isCloned) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertClient(_response);
        });
    }

    protected processCanInsertClient(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    postClientClone(client: ClientCloneApiDto): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostClientClone(_response);
        });
    }

    protected processPostClientClone(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientSecretsApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Secrets?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecrets(_response);
        });
    }

    protected processGetSecrets(response: Response): Promise<ClientSecretsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSecretsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretsApiDto>(null as any);
    }

    postSecret(id: number, clientSecretApi: ClientSecretApiDto): Promise<ClientSecretApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Secrets";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientSecretApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSecret(_response);
        });
    }

    protected processPostSecret(response: Response): Promise<ClientSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientSecretApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretApiDto>(null as any);
    }

    getSecret(secretId: number): Promise<ClientSecretApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new globalThis.Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecret(_response);
        });
    }

    protected processGetSecret(response: Response): Promise<ClientSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSecretApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretApiDto>(null as any);
    }

    deleteSecret(secretId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new globalThis.Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSecret(_response);
        });
    }

    protected processDeleteSecret(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientPropertiesApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Properties?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<ClientPropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertiesApiDto>(null as any);
    }

    postProperty(id: number, clientPropertyApi: ClientPropertyApiDto): Promise<ClientPropertyApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Properties";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientPropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ClientPropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientPropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ClientPropertyApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ClientPropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getClaims(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientClaimsApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Claims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaims(_response);
        });
    }

    protected processGetClaims(response: Response): Promise<ClientClaimsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientClaimsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimsApiDto>(null as any);
    }

    postClaim(id: number, clientClaimApiDto: ClientClaimApiDto): Promise<ClientClaimApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Claims";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientClaimApiDto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostClaim(_response);
        });
    }

    protected processPostClaim(response: Response): Promise<ClientClaimApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientClaimApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimApiDto>(null as any);
    }

    getClaim(claimId: number): Promise<ClientClaimApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new globalThis.Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaim(_response);
        });
    }

    protected processGetClaim(response: Response): Promise<ClientClaimApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientClaimApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimApiDto>(null as any);
    }

    deleteClaim(claimId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Clients/Claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new globalThis.Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteClaim(_response);
        });
    }

    protected processDeleteClaim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IConfigurationIssuesClient {

    get(): Promise<ConfigurationIssueDto[]>;

    getSummary(): Promise<ConfigurationIssueSummaryDto>;
}

export class ConfigurationIssuesClient extends WebApiClientBase implements IConfigurationIssuesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Promise<ConfigurationIssueDto[]> {
        let url_ = this.baseUrl + "/api/ConfigurationIssues";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ConfigurationIssueDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConfigurationIssueDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationIssueDto[]>(null as any);
    }

    getSummary(): Promise<ConfigurationIssueSummaryDto> {
        let url_ = this.baseUrl + "/api/ConfigurationIssues/GetSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<ConfigurationIssueSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationIssueSummaryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationIssueSummaryDto>(null as any);
    }
}

export interface IDashboardClient {

    getDashboardIdentityServer(auditLogsLastNumberOfDays: number | undefined): Promise<DashboardDto>;

    getDashboardIdentity(): Promise<DashboardIdentityDto>;
}

export class DashboardClient extends WebApiClientBase implements IDashboardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getDashboardIdentityServer(auditLogsLastNumberOfDays: number | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardIdentityServer?";
        if (auditLogsLastNumberOfDays === null)
            throw new globalThis.Error("The parameter 'auditLogsLastNumberOfDays' cannot be null.");
        else if (auditLogsLastNumberOfDays !== undefined)
            url_ += "auditLogsLastNumberOfDays=" + encodeURIComponent("" + auditLogsLastNumberOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardIdentityServer(_response);
        });
    }

    protected processGetDashboardIdentityServer(response: Response): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardDto>(null as any);
    }

    getDashboardIdentity(): Promise<DashboardIdentityDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardIdentity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardIdentity(_response);
        });
    }

    protected processGetDashboardIdentity(response: Response): Promise<DashboardIdentityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardIdentityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardIdentityDto>(null as any);
    }
}

export interface IIdentityProvidersClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityProvidersApiDto>;

    post(identityProviderApi: IdentityProviderApiDto): Promise<void>;

    put(identityProviderApi: IdentityProviderApiDto): Promise<FileResponse>;

    canInsertIdentityProvider(id: number | undefined, schema: string | null | undefined): Promise<boolean>;

    get2(id: number): Promise<IdentityProviderApiDto>;

    delete(id: number): Promise<FileResponse>;
}

export class IdentityProvidersClient extends WebApiClientBase implements IIdentityProvidersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityProvidersApiDto> {
        let url_ = this.baseUrl + "/api/IdentityProviders?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityProvidersApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProvidersApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProvidersApiDto>(null as any);
    }

    post(identityProviderApi: IdentityProviderApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityProviderApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    put(identityProviderApi: IdentityProviderApiDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityProviderApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    canInsertIdentityProvider(id: number | undefined, schema: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityProviders/CanInsertIdentityProvider?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (schema !== undefined && schema !== null)
            url_ += "schema=" + encodeURIComponent("" + schema) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityProvider(_response);
        });
    }

    protected processCanInsertIdentityProvider(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    get2(id: number): Promise<IdentityProviderApiDto> {
        let url_ = this.baseUrl + "/api/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityProviderApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProviderApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProviderApiDto>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IIdentityResourcesClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcesApiDto>;

    post(identityResourceApi: IdentityResourceApiDto): Promise<IdentityResourceApiDto>;

    put(identityResourceApi: IdentityResourceApiDto): Promise<void>;

    get2(id: number): Promise<IdentityResourceApiDto>;

    delete(id: number): Promise<void>;

    canInsertIdentityResource(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertIdentityResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcePropertiesApiDto>;

    postProperty(id: number, identityResourcePropertyApi: IdentityResourcePropertyApiDto): Promise<IdentityResourcePropertyApiDto>;

    getProperty(propertyId: number): Promise<IdentityResourcePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class IdentityResourcesClient extends WebApiClientBase implements IIdentityResourcesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcesApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityResourcesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcesApiDto>(null as any);
    }

    post(identityResourceApi: IdentityResourceApiDto): Promise<IdentityResourceApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityResourceApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourceApiDto>(null as any);
    }

    put(identityResourceApi: IdentityResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    get2(id: number): Promise<IdentityResourceApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourceApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourceApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertIdentityResource(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityResources/CanInsertIdentityResource?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityResource(_response);
        });
    }

    protected processCanInsertIdentityResource(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertIdentityResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityResources/CanInsertIdentityResourceProperty?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityResourceProperty(_response);
        });
    }

    protected processCanInsertIdentityResourceProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}/Properties?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<IdentityResourcePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertiesApiDto>(null as any);
    }

    postProperty(id: number, identityResourcePropertyApi: IdentityResourcePropertyApiDto): Promise<IdentityResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}/Properties";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourcePropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<IdentityResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityResourcePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<IdentityResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<IdentityResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new globalThis.Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IInfoClient {

    getApplicationVersion(): Promise<string>;

    getApplicationName(): Promise<string>;
}

export class InfoClient extends WebApiClientBase implements IInfoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getApplicationVersion(): Promise<string> {
        let url_ = this.baseUrl + "/api/Info/GetApplicationVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApplicationVersion(_response);
        });
    }

    protected processGetApplicationVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getApplicationName(): Promise<string> {
        let url_ = this.baseUrl + "/api/Info/GetApplicationName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApplicationName(_response);
        });
    }

    protected processGetApplicationName(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IKeysClient {

    get(page: number | undefined, pageSize: number | undefined): Promise<KeysApiDto>;

    get2(id: string): Promise<KeyApiDto>;

    delete(id: string): Promise<FileResponse>;
}

export class KeysClient extends WebApiClientBase implements IKeysClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(page: number | undefined, pageSize: number | undefined): Promise<KeysApiDto> {
        let url_ = this.baseUrl + "/api/Keys?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<KeysApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeysApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeysApiDto>(null as any);
    }

    get2(id: string): Promise<KeyApiDto> {
        let url_ = this.baseUrl + "/api/Keys/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<KeyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyApiDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Keys/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ILogsClient {

    auditLog(event: string | null | undefined, source: string | null | undefined, category: string | null | undefined, createdDate: string | null | undefined, subjectIdentifier: string | null | undefined, subjectName: string | null | undefined, pageSize: number | undefined, page: number | undefined): Promise<AuditLogsDto>;
}

export class LogsClient extends WebApiClientBase implements ILogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    auditLog(event: string | null | undefined, source: string | null | undefined, category: string | null | undefined, createdDate: string | null | undefined, subjectIdentifier: string | null | undefined, subjectName: string | null | undefined, pageSize: number | undefined, page: number | undefined): Promise<AuditLogsDto> {
        let url_ = this.baseUrl + "/api/Logs/AuditLog?";
        if (event !== undefined && event !== null)
            url_ += "Event=" + encodeURIComponent("" + event) + "&";
        if (source !== undefined && source !== null)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        if (category !== undefined && category !== null)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        if (createdDate !== undefined && createdDate !== null)
            url_ += "CreatedDate=" + encodeURIComponent("" + createdDate) + "&";
        if (subjectIdentifier !== undefined && subjectIdentifier !== null)
            url_ += "SubjectIdentifier=" + encodeURIComponent("" + subjectIdentifier) + "&";
        if (subjectName !== undefined && subjectName !== null)
            url_ += "SubjectName=" + encodeURIComponent("" + subjectName) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuditLog(_response);
        });
    }

    protected processAuditLog(response: Response): Promise<AuditLogsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditLogsDto>(null as any);
    }
}

export interface IPersistedGrantsClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantSubjectsApiDto>;

    get2(id: string): Promise<PersistedGrantApiDto>;

    delete(id: string): Promise<FileResponse>;

    getBySubject(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantsApiDto>;

    deleteBySubject(subjectId: string): Promise<FileResponse>;
}

export class PersistedGrantsClient extends WebApiClientBase implements IPersistedGrantsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantSubjectsApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PersistedGrantSubjectsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantSubjectsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantSubjectsApiDto>(null as any);
    }

    get2(id: string): Promise<PersistedGrantApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<PersistedGrantApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantApiDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/PersistedGrants/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getBySubject(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantsApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects/{subjectId}?";
        if (subjectId === undefined || subjectId === null)
            throw new globalThis.Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBySubject(_response);
        });
    }

    protected processGetBySubject(response: Response): Promise<PersistedGrantsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantsApiDto>(null as any);
    }

    deleteBySubject(subjectId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects/{subjectId}";
        if (subjectId === undefined || subjectId === null)
            throw new globalThis.Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteBySubject(_response);
        });
    }

    protected processDeleteBySubject(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IRolesClient {

    get(id: string): Promise<IdentityRoleDto>;

    delete(id: string): Promise<FileResponse>;

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityRolesDto>;

    post(role: IdentityRoleDto): Promise<IdentityRoleDto>;

    put(role: IdentityRoleDto): Promise<FileResponse>;

    getRoleUsers(id: string, searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    getRoleClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString>;

    deleteRoleClaims(id: string, claimId: number | undefined): Promise<FileResponse>;

    postRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse>;

    putRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse>;
}

export class RolesClient extends WebApiClientBase implements IRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(id: string): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityRoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityRolesDto> {
        let url_ = this.baseUrl + "/api/Roles?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityRolesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityRolesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRolesDto>(null as any);
    }

    post(role: IdentityRoleDto): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityRoleDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    put(role: IdentityRoleDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRoleUsers(id: string, searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Users?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleUsers(_response);
        });
    }

    protected processGetRoleUsers(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    getRoleClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Claims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleClaims(_response);
        });
    }

    protected processGetRoleClaims(response: Response): Promise<RoleClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleClaimsApiDtoOfString>(null as any);
    }

    deleteRoleClaims(id: string, claimId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Claims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimId === null)
            throw new globalThis.Error("The parameter 'claimId' cannot be null.");
        else if (claimId !== undefined)
            url_ += "claimId=" + encodeURIComponent("" + claimId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRoleClaims(_response);
        });
    }

    protected processDeleteRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleClaims);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostRoleClaims(_response);
        });
    }

    protected processPostRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    putRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleClaims);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutRoleClaims(_response);
        });
    }

    protected processPutRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IUsersClient {

    get(id: string): Promise<IdentityUserDto>;

    delete(id: string): Promise<FileResponse>;

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    post(user: IdentityUserDto): Promise<IdentityUserDto>;

    put(user: IdentityUserDto): Promise<FileResponse>;

    getUserRoles(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserRolesApiDtoOfIdentityRoleDto>;

    postUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse>;

    deleteUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse>;

    getUserClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserClaimsApiDtoOfString>;

    deleteUserClaims(id: string, claimId: number | undefined): Promise<FileResponse>;

    postUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse>;

    putUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse>;

    getUserProviders(id: string): Promise<UserProvidersApiDtoOfString>;

    deleteUserProviders(provider: UserProviderDeleteApiDtoOfString): Promise<FileResponse>;

    postChangePassword(password: UserChangePasswordApiDtoOfString): Promise<FileResponse>;

    getRoleClaims(id: string, claimSearchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString>;

    getClaimUsers(claimType: string, claimValue: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    getClaimUsers2(claimType: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;
}

export class UsersClient extends WebApiClientBase implements IUsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(id: string): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    post(user: IdentityUserDto): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityUserDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    put(user: IdentityUserDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserRoles(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserRolesApiDtoOfIdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/Roles?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserRoles(_response);
        });
    }

    protected processGetUserRoles(response: Response): Promise<UserRolesApiDtoOfIdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRolesApiDtoOfIdentityRoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRolesApiDtoOfIdentityRoleDto>(null as any);
    }

    postUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostUserRoles(_response);
        });
    }

    protected processPostUserRoles(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserRoles(_response);
        });
    }

    protected processDeleteUserRoles(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/Claims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserClaims(_response);
        });
    }

    protected processGetUserClaims(response: Response): Promise<UserClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserClaimsApiDtoOfString>(null as any);
    }

    deleteUserClaims(id: string, claimId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/Claims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimId === null)
            throw new globalThis.Error("The parameter 'claimId' cannot be null.");
        else if (claimId !== undefined)
            url_ += "claimId=" + encodeURIComponent("" + claimId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserClaims(_response);
        });
    }

    protected processDeleteUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claim);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostUserClaims(_response);
        });
    }

    protected processPostUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    putUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claim);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutUserClaims(_response);
        });
    }

    protected processPutUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserProviders(id: string): Promise<UserProvidersApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/Providers";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserProviders(_response);
        });
    }

    protected processGetUserProviders(response: Response): Promise<UserProvidersApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProvidersApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProvidersApiDtoOfString>(null as any);
    }

    deleteUserProviders(provider: UserProviderDeleteApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Providers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(provider);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserProviders(_response);
        });
    }

    protected processDeleteUserProviders(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postChangePassword(password: UserChangePasswordApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(password);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostChangePassword(_response);
        });
    }

    protected processPostChangePassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRoleClaims(id: string, claimSearchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/RoleClaims?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimSearchText !== undefined && claimSearchText !== null)
            url_ += "claimSearchText=" + encodeURIComponent("" + claimSearchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleClaims(_response);
        });
    }

    protected processGetRoleClaims(response: Response): Promise<RoleClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleClaimsApiDtoOfString>(null as any);
    }

    getClaimUsers(claimType: string, claimValue: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users/ClaimType/{claimType}/ClaimValue/{claimValue}?";
        if (claimType === undefined || claimType === null)
            throw new globalThis.Error("The parameter 'claimType' must be defined.");
        url_ = url_.replace("{claimType}", encodeURIComponent("" + claimType));
        if (claimValue === undefined || claimValue === null)
            throw new globalThis.Error("The parameter 'claimValue' must be defined.");
        url_ = url_.replace("{claimValue}", encodeURIComponent("" + claimValue));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaimUsers(_response);
        });
    }

    protected processGetClaimUsers(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    getClaimUsers2(claimType: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users/ClaimType/{claimType}?";
        if (claimType === undefined || claimType === null)
            throw new globalThis.Error("The parameter 'claimType' must be defined.");
        url_ = url_.replace("{claimType}", encodeURIComponent("" + claimType));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaimUsers2(_response);
        });
    }

    protected processGetClaimUsers2(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }
}

export class ApiResourcesApiDto implements IApiResourcesApiDto {
    pageSize!: number;
    totalCount!: number;
    apiResources!: ApiResourceApiDto[] | undefined;

    constructor(data?: IApiResourcesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["apiResources"])) {
                this.apiResources = [] as any;
                for (let item of _data["apiResources"])
                    this.apiResources!.push(ApiResourceApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResourcesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.apiResources)) {
            data["apiResources"] = [];
            for (let item of this.apiResources)
                data["apiResources"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IApiResourcesApiDto {
    pageSize: number;
    totalCount: number;
    apiResources: ApiResourceApiDto[] | undefined;
}

export class ApiResourceApiDto implements IApiResourceApiDto {
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    showInDiscoveryDocument!: boolean;
    requireResourceIndicator!: boolean;
    userClaims!: string[] | undefined;
    allowedAccessTokenSigningAlgorithms!: string[] | undefined;
    scopes!: string[] | undefined;

    constructor(data?: IApiResourceApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.requireResourceIndicator = _data["requireResourceIndicator"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (Array.isArray(_data["allowedAccessTokenSigningAlgorithms"])) {
                this.allowedAccessTokenSigningAlgorithms = [] as any;
                for (let item of _data["allowedAccessTokenSigningAlgorithms"])
                    this.allowedAccessTokenSigningAlgorithms!.push(item);
            }
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResourceApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["requireResourceIndicator"] = this.requireResourceIndicator;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (Array.isArray(this.allowedAccessTokenSigningAlgorithms)) {
            data["allowedAccessTokenSigningAlgorithms"] = [];
            for (let item of this.allowedAccessTokenSigningAlgorithms)
                data["allowedAccessTokenSigningAlgorithms"].push(item);
        }
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

export interface IApiResourceApiDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    enabled: boolean;
    showInDiscoveryDocument: boolean;
    requireResourceIndicator: boolean;
    userClaims: string[] | undefined;
    allowedAccessTokenSigningAlgorithms: string[] | undefined;
    scopes: string[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class ApiSecretsApiDto implements IApiSecretsApiDto {
    totalCount!: number;
    pageSize!: number;
    apiSecrets!: ApiSecretApiDto[] | undefined;

    constructor(data?: IApiSecretsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["apiSecrets"])) {
                this.apiSecrets = [] as any;
                for (let item of _data["apiSecrets"])
                    this.apiSecrets!.push(ApiSecretApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiSecretsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSecretsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.apiSecrets)) {
            data["apiSecrets"] = [];
            for (let item of this.apiSecrets)
                data["apiSecrets"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IApiSecretsApiDto {
    totalCount: number;
    pageSize: number;
    apiSecrets: ApiSecretApiDto[] | undefined;
}

export class ApiSecretApiDto implements IApiSecretApiDto {
    type!: string;
    id!: number;
    description!: string | undefined;
    value!: string;
    hashType!: string | undefined;
    expiration!: Date | undefined;
    created!: Date;

    constructor(data?: IApiSecretApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.hashType = _data["hashType"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : undefined as any;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ApiSecretApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSecretApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["description"] = this.description;
        data["value"] = this.value;
        data["hashType"] = this.hashType;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : undefined as any;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        return data;
    }
}

export interface IApiSecretApiDto {
    type: string;
    id: number;
    description: string | undefined;
    value: string;
    hashType: string | undefined;
    expiration: Date | undefined;
    created: Date;
}

export class ApiResourcePropertiesApiDto implements IApiResourcePropertiesApiDto {
    apiResourceProperties!: ApiResourcePropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IApiResourcePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["apiResourceProperties"])) {
                this.apiResourceProperties = [] as any;
                for (let item of _data["apiResourceProperties"])
                    this.apiResourceProperties!.push(ApiResourcePropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ApiResourcePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.apiResourceProperties)) {
            data["apiResourceProperties"] = [];
            for (let item of this.apiResourceProperties)
                data["apiResourceProperties"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IApiResourcePropertiesApiDto {
    apiResourceProperties: ApiResourcePropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ApiResourcePropertyApiDto implements IApiResourcePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiResourcePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiResourcePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiResourcePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ApiScopesApiDto implements IApiScopesApiDto {
    pageSize!: number;
    totalCount!: number;
    scopes!: ApiScopeApiDto[] | undefined;

    constructor(data?: IApiScopesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(ApiScopeApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IApiScopesApiDto {
    pageSize: number;
    totalCount: number;
    scopes: ApiScopeApiDto[] | undefined;
}

export class ApiScopeApiDto implements IApiScopeApiDto {
    showInDiscoveryDocument!: boolean;
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    required!: boolean;
    emphasize!: boolean;
    enabled!: boolean;
    userClaims!: string[] | undefined;
    apiScopeProperties!: ApiScopePropertyApiDto[] | undefined;

    constructor(data?: IApiScopeApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopeApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IApiScopeApiDto {
    showInDiscoveryDocument: boolean;
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    required: boolean;
    emphasize: boolean;
    enabled: boolean;
    userClaims: string[] | undefined;
    apiScopeProperties: ApiScopePropertyApiDto[] | undefined;
}

export class ApiScopePropertyApiDto implements IApiScopePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiScopePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiScopePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiScopePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ApiScopePropertiesApiDto implements IApiScopePropertiesApiDto {
    apiScopeProperties!: ApiScopePropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IApiScopePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ApiScopePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IApiScopePropertiesApiDto {
    apiScopeProperties: ApiScopePropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ApiScopeDto implements IApiScopeDto {
    showInDiscoveryDocument!: boolean;
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    required!: boolean;
    emphasize!: boolean;
    userClaims!: string[] | undefined;
    userClaimsItems!: string | undefined;
    enabled!: boolean;
    apiScopeProperties!: ApiScopePropertyDto[] | undefined;

    constructor(data?: IApiScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            this.userClaimsItems = _data["userClaimsItems"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        data["userClaimsItems"] = this.userClaimsItems;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IApiScopeDto {
    showInDiscoveryDocument: boolean;
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    required: boolean;
    emphasize: boolean;
    userClaims: string[] | undefined;
    userClaimsItems: string | undefined;
    enabled: boolean;
    apiScopeProperties: ApiScopePropertyDto[] | undefined;
}

export class ApiScopePropertyDto implements IApiScopePropertyDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiScopePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiScopePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiScopePropertyDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ClientsApiDto implements IClientsApiDto {
    clients!: ClientApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clients"])) {
                this.clients = [] as any;
                for (let item of _data["clients"])
                    this.clients!.push(ClientApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clients)) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientsApiDto {
    clients: ClientApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ClientApiDto implements IClientApiDto {
    absoluteRefreshTokenLifetime!: number;
    accessTokenLifetime!: number;
    consentLifetime!: number | undefined;
    accessTokenType!: number;
    allowAccessTokensViaBrowser!: boolean;
    allowOfflineAccess!: boolean;
    allowPlainTextPkce!: boolean;
    allowRememberConsent!: boolean;
    alwaysIncludeUserClaimsInIdToken!: boolean;
    alwaysSendClientClaims!: boolean;
    authorizationCodeLifetime!: number;
    frontChannelLogoutUri!: string | undefined;
    frontChannelLogoutSessionRequired!: boolean;
    backChannelLogoutUri!: string | undefined;
    backChannelLogoutSessionRequired!: boolean;
    clientId!: string;
    clientName!: string;
    clientUri!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    enableLocalLogin!: boolean;
    id!: number;
    identityTokenLifetime!: number;
    includeJwtId!: boolean;
    logoUri!: string | undefined;
    clientClaimsPrefix!: string | undefined;
    pairWiseSubjectSalt!: string | undefined;
    protocolType!: string | undefined;
    refreshTokenExpiration!: number;
    refreshTokenUsage!: number;
    slidingRefreshTokenLifetime!: number;
    requireClientSecret!: boolean;
    requireConsent!: boolean;
    requirePkce!: boolean;
    updateAccessTokenClaimsOnRefresh!: boolean;
    postLogoutRedirectUris!: string[] | undefined;
    identityProviderRestrictions!: string[] | undefined;
    redirectUris!: string[] | undefined;
    allowedCorsOrigins!: string[] | undefined;
    allowedGrantTypes!: string[] | undefined;
    allowedScopes!: string[] | undefined;
    claims!: ClientClaimApiDto[] | undefined;
    properties!: ClientPropertyApiDto[] | undefined;
    updated!: Date | undefined;
    lastAccessed!: Date | undefined;
    userSsoLifetime!: number | undefined;
    userCodeType!: string | undefined;
    deviceCodeLifetime!: number;
    requireRequestObject!: boolean;
    cibaLifetime!: number | undefined;
    pollingInterval!: number | undefined;
    coordinateLifetimeWithUserSession!: boolean;
    requireDPoP!: boolean;
    dPoPValidationMode!: number;
    dPoPClockSkew!: string;
    pushedAuthorizationLifetime!: number | undefined;
    requirePushedAuthorization!: boolean;
    initiateLoginUri!: string | undefined;
    allowedIdentityTokenSigningAlgorithms!: string[] | undefined;
    nonEditable!: boolean;

    constructor(data?: IClientApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.accessTokenType = _data["accessTokenType"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.clientUri = _data["clientUri"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            this.id = _data["id"];
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            this.includeJwtId = _data["includeJwtId"];
            this.logoUri = _data["logoUri"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.protocolType = _data["protocolType"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.requireClientSecret = _data["requireClientSecret"];
            this.requireConsent = _data["requireConsent"];
            this.requirePkce = _data["requirePkce"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["identityProviderRestrictions"])) {
                this.identityProviderRestrictions = [] as any;
                for (let item of _data["identityProviderRestrictions"])
                    this.identityProviderRestrictions!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            if (Array.isArray(_data["allowedCorsOrigins"])) {
                this.allowedCorsOrigins = [] as any;
                for (let item of _data["allowedCorsOrigins"])
                    this.allowedCorsOrigins!.push(item);
            }
            if (Array.isArray(_data["allowedGrantTypes"])) {
                this.allowedGrantTypes = [] as any;
                for (let item of _data["allowedGrantTypes"])
                    this.allowedGrantTypes!.push(item);
            }
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClientClaimApiDto.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ClientPropertyApiDto.fromJS(item));
            }
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : undefined as any;
            this.lastAccessed = _data["lastAccessed"] ? new Date(_data["lastAccessed"].toString()) : undefined as any;
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.userCodeType = _data["userCodeType"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            this.requireRequestObject = _data["requireRequestObject"];
            this.cibaLifetime = _data["cibaLifetime"];
            this.pollingInterval = _data["pollingInterval"];
            this.coordinateLifetimeWithUserSession = _data["coordinateLifetimeWithUserSession"];
            this.requireDPoP = _data["requireDPoP"];
            this.dPoPValidationMode = _data["dPoPValidationMode"];
            this.dPoPClockSkew = _data["dPoPClockSkew"];
            this.pushedAuthorizationLifetime = _data["pushedAuthorizationLifetime"];
            this.requirePushedAuthorization = _data["requirePushedAuthorization"];
            this.initiateLoginUri = _data["initiateLoginUri"];
            if (Array.isArray(_data["allowedIdentityTokenSigningAlgorithms"])) {
                this.allowedIdentityTokenSigningAlgorithms = [] as any;
                for (let item of _data["allowedIdentityTokenSigningAlgorithms"])
                    this.allowedIdentityTokenSigningAlgorithms!.push(item);
            }
            this.nonEditable = _data["nonEditable"];
        }
    }

    static fromJS(data: any): ClientApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["accessTokenType"] = this.accessTokenType;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["clientUri"] = this.clientUri;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["enableLocalLogin"] = this.enableLocalLogin;
        data["id"] = this.id;
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        data["includeJwtId"] = this.includeJwtId;
        data["logoUri"] = this.logoUri;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["protocolType"] = this.protocolType;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["requireClientSecret"] = this.requireClientSecret;
        data["requireConsent"] = this.requireConsent;
        data["requirePkce"] = this.requirePkce;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.identityProviderRestrictions)) {
            data["identityProviderRestrictions"] = [];
            for (let item of this.identityProviderRestrictions)
                data["identityProviderRestrictions"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.allowedCorsOrigins)) {
            data["allowedCorsOrigins"] = [];
            for (let item of this.allowedCorsOrigins)
                data["allowedCorsOrigins"].push(item);
        }
        if (Array.isArray(this.allowedGrantTypes)) {
            data["allowedGrantTypes"] = [];
            for (let item of this.allowedGrantTypes)
                data["allowedGrantTypes"].push(item);
        }
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item ? item.toJSON() : undefined as any);
        }
        data["updated"] = this.updated ? this.updated.toISOString() : undefined as any;
        data["lastAccessed"] = this.lastAccessed ? this.lastAccessed.toISOString() : undefined as any;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["userCodeType"] = this.userCodeType;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        data["requireRequestObject"] = this.requireRequestObject;
        data["cibaLifetime"] = this.cibaLifetime;
        data["pollingInterval"] = this.pollingInterval;
        data["coordinateLifetimeWithUserSession"] = this.coordinateLifetimeWithUserSession;
        data["requireDPoP"] = this.requireDPoP;
        data["dPoPValidationMode"] = this.dPoPValidationMode;
        data["dPoPClockSkew"] = this.dPoPClockSkew;
        data["pushedAuthorizationLifetime"] = this.pushedAuthorizationLifetime;
        data["requirePushedAuthorization"] = this.requirePushedAuthorization;
        data["initiateLoginUri"] = this.initiateLoginUri;
        if (Array.isArray(this.allowedIdentityTokenSigningAlgorithms)) {
            data["allowedIdentityTokenSigningAlgorithms"] = [];
            for (let item of this.allowedIdentityTokenSigningAlgorithms)
                data["allowedIdentityTokenSigningAlgorithms"].push(item);
        }
        data["nonEditable"] = this.nonEditable;
        return data;
    }
}

export interface IClientApiDto {
    absoluteRefreshTokenLifetime: number;
    accessTokenLifetime: number;
    consentLifetime: number | undefined;
    accessTokenType: number;
    allowAccessTokensViaBrowser: boolean;
    allowOfflineAccess: boolean;
    allowPlainTextPkce: boolean;
    allowRememberConsent: boolean;
    alwaysIncludeUserClaimsInIdToken: boolean;
    alwaysSendClientClaims: boolean;
    authorizationCodeLifetime: number;
    frontChannelLogoutUri: string | undefined;
    frontChannelLogoutSessionRequired: boolean;
    backChannelLogoutUri: string | undefined;
    backChannelLogoutSessionRequired: boolean;
    clientId: string;
    clientName: string;
    clientUri: string | undefined;
    description: string | undefined;
    enabled: boolean;
    enableLocalLogin: boolean;
    id: number;
    identityTokenLifetime: number;
    includeJwtId: boolean;
    logoUri: string | undefined;
    clientClaimsPrefix: string | undefined;
    pairWiseSubjectSalt: string | undefined;
    protocolType: string | undefined;
    refreshTokenExpiration: number;
    refreshTokenUsage: number;
    slidingRefreshTokenLifetime: number;
    requireClientSecret: boolean;
    requireConsent: boolean;
    requirePkce: boolean;
    updateAccessTokenClaimsOnRefresh: boolean;
    postLogoutRedirectUris: string[] | undefined;
    identityProviderRestrictions: string[] | undefined;
    redirectUris: string[] | undefined;
    allowedCorsOrigins: string[] | undefined;
    allowedGrantTypes: string[] | undefined;
    allowedScopes: string[] | undefined;
    claims: ClientClaimApiDto[] | undefined;
    properties: ClientPropertyApiDto[] | undefined;
    updated: Date | undefined;
    lastAccessed: Date | undefined;
    userSsoLifetime: number | undefined;
    userCodeType: string | undefined;
    deviceCodeLifetime: number;
    requireRequestObject: boolean;
    cibaLifetime: number | undefined;
    pollingInterval: number | undefined;
    coordinateLifetimeWithUserSession: boolean;
    requireDPoP: boolean;
    dPoPValidationMode: number;
    dPoPClockSkew: string;
    pushedAuthorizationLifetime: number | undefined;
    requirePushedAuthorization: boolean;
    initiateLoginUri: string | undefined;
    allowedIdentityTokenSigningAlgorithms: string[] | undefined;
    nonEditable: boolean;
}

export class ClientClaimApiDto implements IClientClaimApiDto {
    id!: number;
    type!: string;
    value!: string;

    constructor(data?: IClientClaimApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ClientClaimApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientClaimApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IClientClaimApiDto {
    id: number;
    type: string;
    value: string;
}

export class ClientPropertyApiDto implements IClientPropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IClientPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ClientPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IClientPropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class SelectItemDto implements ISelectItemDto {
    id!: string | undefined;
    text!: string | undefined;

    constructor(data?: ISelectItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): SelectItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface ISelectItemDto {
    id: string | undefined;
    text: string | undefined;
}

export class ClientCloneApiDto implements IClientCloneApiDto {
    id!: number;
    clientId!: string;
    clientName!: string;
    cloneClientCorsOrigins!: boolean;
    cloneClientRedirectUris!: boolean;
    cloneClientIdPRestrictions!: boolean;
    cloneClientPostLogoutRedirectUris!: boolean;
    cloneClientGrantTypes!: boolean;
    cloneClientScopes!: boolean;
    cloneClientClaims!: boolean;
    cloneClientProperties!: boolean;

    constructor(data?: IClientCloneApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.cloneClientCorsOrigins = _data["cloneClientCorsOrigins"];
            this.cloneClientRedirectUris = _data["cloneClientRedirectUris"];
            this.cloneClientIdPRestrictions = _data["cloneClientIdPRestrictions"];
            this.cloneClientPostLogoutRedirectUris = _data["cloneClientPostLogoutRedirectUris"];
            this.cloneClientGrantTypes = _data["cloneClientGrantTypes"];
            this.cloneClientScopes = _data["cloneClientScopes"];
            this.cloneClientClaims = _data["cloneClientClaims"];
            this.cloneClientProperties = _data["cloneClientProperties"];
        }
    }

    static fromJS(data: any): ClientCloneApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCloneApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["cloneClientCorsOrigins"] = this.cloneClientCorsOrigins;
        data["cloneClientRedirectUris"] = this.cloneClientRedirectUris;
        data["cloneClientIdPRestrictions"] = this.cloneClientIdPRestrictions;
        data["cloneClientPostLogoutRedirectUris"] = this.cloneClientPostLogoutRedirectUris;
        data["cloneClientGrantTypes"] = this.cloneClientGrantTypes;
        data["cloneClientScopes"] = this.cloneClientScopes;
        data["cloneClientClaims"] = this.cloneClientClaims;
        data["cloneClientProperties"] = this.cloneClientProperties;
        return data;
    }
}

export interface IClientCloneApiDto {
    id: number;
    clientId: string;
    clientName: string;
    cloneClientCorsOrigins: boolean;
    cloneClientRedirectUris: boolean;
    cloneClientIdPRestrictions: boolean;
    cloneClientPostLogoutRedirectUris: boolean;
    cloneClientGrantTypes: boolean;
    cloneClientScopes: boolean;
    cloneClientClaims: boolean;
    cloneClientProperties: boolean;
}

export class ClientSecretsApiDto implements IClientSecretsApiDto {
    totalCount!: number;
    pageSize!: number;
    clientSecrets!: ClientSecretApiDto[] | undefined;

    constructor(data?: IClientSecretsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["clientSecrets"])) {
                this.clientSecrets = [] as any;
                for (let item of _data["clientSecrets"])
                    this.clientSecrets!.push(ClientSecretApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientSecretsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSecretsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.clientSecrets)) {
            data["clientSecrets"] = [];
            for (let item of this.clientSecrets)
                data["clientSecrets"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IClientSecretsApiDto {
    totalCount: number;
    pageSize: number;
    clientSecrets: ClientSecretApiDto[] | undefined;
}

export class ClientSecretApiDto implements IClientSecretApiDto {
    type!: string;
    id!: number;
    description!: string | undefined;
    value!: string;
    hashType!: string | undefined;
    expiration!: Date | undefined;
    created!: Date;

    constructor(data?: IClientSecretApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.hashType = _data["hashType"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : undefined as any;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ClientSecretApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSecretApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["description"] = this.description;
        data["value"] = this.value;
        data["hashType"] = this.hashType;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : undefined as any;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        return data;
    }
}

export interface IClientSecretApiDto {
    type: string;
    id: number;
    description: string | undefined;
    value: string;
    hashType: string | undefined;
    expiration: Date | undefined;
    created: Date;
}

export class ClientPropertiesApiDto implements IClientPropertiesApiDto {
    clientProperties!: ClientPropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientPropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientProperties"])) {
                this.clientProperties = [] as any;
                for (let item of _data["clientProperties"])
                    this.clientProperties!.push(ClientPropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientPropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientProperties)) {
            data["clientProperties"] = [];
            for (let item of this.clientProperties)
                data["clientProperties"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientPropertiesApiDto {
    clientProperties: ClientPropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ClientClaimsApiDto implements IClientClaimsApiDto {
    clientClaims!: ClientClaimApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientClaimsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientClaims"])) {
                this.clientClaims = [] as any;
                for (let item of _data["clientClaims"])
                    this.clientClaims!.push(ClientClaimApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientClaimsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientClaimsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientClaims)) {
            data["clientClaims"] = [];
            for (let item of this.clientClaims)
                data["clientClaims"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientClaimsApiDto {
    clientClaims: ClientClaimApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ConfigurationIssueDto implements IConfigurationIssueDto {
    resourceId!: number;
    resourceName!: string | undefined;
    message!: ConfigurationIssueMessageEnum;
    issueType!: ConfigurationIssueTypeView;
    resourceType!: ConfigurationResourceType;

    constructor(data?: IConfigurationIssueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            this.message = _data["message"];
            this.issueType = _data["issueType"];
            this.resourceType = _data["resourceType"];
        }
    }

    static fromJS(data: any): ConfigurationIssueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIssueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        data["message"] = this.message;
        data["issueType"] = this.issueType;
        data["resourceType"] = this.resourceType;
        return data;
    }
}

export interface IConfigurationIssueDto {
    resourceId: number;
    resourceName: string | undefined;
    message: ConfigurationIssueMessageEnum;
    issueType: ConfigurationIssueTypeView;
    resourceType: ConfigurationResourceType;
}

export enum ConfigurationIssueMessageEnum {
    ObsoleteImplicitGrant = 0,
    ObsoletePasswordGrant = 1,
    MissingPkce = 2,
}

export enum ConfigurationIssueTypeView {
    Warning = 0,
    Recommendation = 1,
}

export enum ConfigurationResourceType {
    Client = 0,
    IdentityResource = 1,
    ApiResource = 2,
    ApiScope = 3,
}

export class ConfigurationIssueSummaryDto implements IConfigurationIssueSummaryDto {
    warnings!: number;
    recommendations!: number;

    constructor(data?: IConfigurationIssueSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.warnings = _data["warnings"];
            this.recommendations = _data["recommendations"];
        }
    }

    static fromJS(data: any): ConfigurationIssueSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIssueSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warnings"] = this.warnings;
        data["recommendations"] = this.recommendations;
        return data;
    }
}

export interface IConfigurationIssueSummaryDto {
    warnings: number;
    recommendations: number;
}

export class DashboardDto implements IDashboardDto {
    clientsTotal!: number;
    apiResourcesTotal!: number;
    apiScopesTotal!: number;
    identityResourcesTotal!: number;
    identityProvidersTotal!: number;
    auditLogsAvg!: number;
    auditLogsPerDaysTotal!: DashboardAuditLogDto[] | undefined;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientsTotal = _data["clientsTotal"];
            this.apiResourcesTotal = _data["apiResourcesTotal"];
            this.apiScopesTotal = _data["apiScopesTotal"];
            this.identityResourcesTotal = _data["identityResourcesTotal"];
            this.identityProvidersTotal = _data["identityProvidersTotal"];
            this.auditLogsAvg = _data["auditLogsAvg"];
            if (Array.isArray(_data["auditLogsPerDaysTotal"])) {
                this.auditLogsPerDaysTotal = [] as any;
                for (let item of _data["auditLogsPerDaysTotal"])
                    this.auditLogsPerDaysTotal!.push(DashboardAuditLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientsTotal"] = this.clientsTotal;
        data["apiResourcesTotal"] = this.apiResourcesTotal;
        data["apiScopesTotal"] = this.apiScopesTotal;
        data["identityResourcesTotal"] = this.identityResourcesTotal;
        data["identityProvidersTotal"] = this.identityProvidersTotal;
        data["auditLogsAvg"] = this.auditLogsAvg;
        if (Array.isArray(this.auditLogsPerDaysTotal)) {
            data["auditLogsPerDaysTotal"] = [];
            for (let item of this.auditLogsPerDaysTotal)
                data["auditLogsPerDaysTotal"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IDashboardDto {
    clientsTotal: number;
    apiResourcesTotal: number;
    apiScopesTotal: number;
    identityResourcesTotal: number;
    identityProvidersTotal: number;
    auditLogsAvg: number;
    auditLogsPerDaysTotal: DashboardAuditLogDto[] | undefined;
}

export class DashboardAuditLogDto implements IDashboardAuditLogDto {
    total!: number;
    created!: Date;

    constructor(data?: IDashboardAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DashboardAuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardAuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        return data;
    }
}

export interface IDashboardAuditLogDto {
    total: number;
    created: Date;
}

export class DashboardIdentityDto implements IDashboardIdentityDto {
    usersTotal!: number;
    rolesTotal!: number;

    constructor(data?: IDashboardIdentityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usersTotal = _data["usersTotal"];
            this.rolesTotal = _data["rolesTotal"];
        }
    }

    static fromJS(data: any): DashboardIdentityDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardIdentityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usersTotal"] = this.usersTotal;
        data["rolesTotal"] = this.rolesTotal;
        return data;
    }
}

export interface IDashboardIdentityDto {
    usersTotal: number;
    rolesTotal: number;
}

export class IdentityProvidersApiDto implements IIdentityProvidersApiDto {
    pageSize!: number;
    totalCount!: number;
    identityProviders!: IdentityProviderApiDto[] | undefined;

    constructor(data?: IIdentityProvidersApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["identityProviders"])) {
                this.identityProviders = [] as any;
                for (let item of _data["identityProviders"])
                    this.identityProviders!.push(IdentityProviderApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityProvidersApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProvidersApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.identityProviders)) {
            data["identityProviders"] = [];
            for (let item of this.identityProviders)
                data["identityProviders"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IIdentityProvidersApiDto {
    pageSize: number;
    totalCount: number;
    identityProviders: IdentityProviderApiDto[] | undefined;
}

export class IdentityProviderApiDto implements IIdentityProviderApiDto {
    type!: string | undefined;
    id!: number;
    scheme!: string;
    displayName!: string | undefined;
    enabled!: boolean;
    identityProviderProperties!: { [key: string]: string; } | undefined;

    constructor(data?: IIdentityProviderApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.scheme = _data["scheme"];
            this.displayName = _data["displayName"];
            this.enabled = _data["enabled"];
            if (_data["identityProviderProperties"]) {
                this.identityProviderProperties = {} as any;
                for (let key in _data["identityProviderProperties"]) {
                    if (_data["identityProviderProperties"].hasOwnProperty(key))
                        (this.identityProviderProperties as any)![key] = _data["identityProviderProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IdentityProviderApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProviderApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["scheme"] = this.scheme;
        data["displayName"] = this.displayName;
        data["enabled"] = this.enabled;
        if (this.identityProviderProperties) {
            data["identityProviderProperties"] = {};
            for (let key in this.identityProviderProperties) {
                if (this.identityProviderProperties.hasOwnProperty(key))
                    (data["identityProviderProperties"] as any)[key] = (this.identityProviderProperties as any)[key];
            }
        }
        return data;
    }
}

export interface IIdentityProviderApiDto {
    type: string | undefined;
    id: number;
    scheme: string;
    displayName: string | undefined;
    enabled: boolean;
    identityProviderProperties: { [key: string]: string; } | undefined;
}

export class IdentityResourcesApiDto implements IIdentityResourcesApiDto {
    pageSize!: number;
    totalCount!: number;
    identityResources!: IdentityResourceApiDto[] | undefined;

    constructor(data?: IIdentityResourcesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["identityResources"])) {
                this.identityResources = [] as any;
                for (let item of _data["identityResources"])
                    this.identityResources!.push(IdentityResourceApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResourcesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.identityResources)) {
            data["identityResources"] = [];
            for (let item of this.identityResources)
                data["identityResources"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IIdentityResourcesApiDto {
    pageSize: number;
    totalCount: number;
    identityResources: IdentityResourceApiDto[] | undefined;
}

export class IdentityResourceApiDto implements IIdentityResourceApiDto {
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    showInDiscoveryDocument!: boolean;
    required!: boolean;
    emphasize!: boolean;
    userClaims!: string[] | undefined;

    constructor(data?: IIdentityResourceApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityResourceApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourceApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        return data;
    }
}

export interface IIdentityResourceApiDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    enabled: boolean;
    showInDiscoveryDocument: boolean;
    required: boolean;
    emphasize: boolean;
    userClaims: string[] | undefined;
}

export class IdentityResourcePropertiesApiDto implements IIdentityResourcePropertiesApiDto {
    totalCount!: number;
    pageSize!: number;
    identityResourceProperties!: IdentityResourcePropertyApiDto[] | undefined;

    constructor(data?: IIdentityResourcePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["identityResourceProperties"])) {
                this.identityResourceProperties = [] as any;
                for (let item of _data["identityResourceProperties"])
                    this.identityResourceProperties!.push(IdentityResourcePropertyApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResourcePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.identityResourceProperties)) {
            data["identityResourceProperties"] = [];
            for (let item of this.identityResourceProperties)
                data["identityResourceProperties"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IIdentityResourcePropertiesApiDto {
    totalCount: number;
    pageSize: number;
    identityResourceProperties: IdentityResourcePropertyApiDto[] | undefined;
}

export class IdentityResourcePropertyApiDto implements IIdentityResourcePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IIdentityResourcePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdentityResourcePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IIdentityResourcePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class KeysApiDto implements IKeysApiDto {
    keys!: KeyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IKeysApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["keys"])) {
                this.keys = [] as any;
                for (let item of _data["keys"])
                    this.keys!.push(KeyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): KeysApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeysApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IKeysApiDto {
    keys: KeyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class KeyApiDto implements IKeyApiDto {
    id!: string | undefined;
    version!: number;
    created!: Date;
    use!: string | undefined;
    algorithm!: string | undefined;
    isX509Certificate!: boolean;

    constructor(data?: IKeyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
            this.use = _data["use"];
            this.algorithm = _data["algorithm"];
            this.isX509Certificate = _data["isX509Certificate"];
        }
    }

    static fromJS(data: any): KeyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        data["use"] = this.use;
        data["algorithm"] = this.algorithm;
        data["isX509Certificate"] = this.isX509Certificate;
        return data;
    }
}

export interface IKeyApiDto {
    id: string | undefined;
    version: number;
    created: Date;
    use: string | undefined;
    algorithm: string | undefined;
    isX509Certificate: boolean;
}

export class AuditLogsDto implements IAuditLogsDto {
    deleteOlderThan!: Date;
    logs!: AuditLogDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IAuditLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deleteOlderThan = _data["deleteOlderThan"] ? new Date(_data["deleteOlderThan"].toString()) : undefined as any;
            if (Array.isArray(_data["logs"])) {
                this.logs = [] as any;
                for (let item of _data["logs"])
                    this.logs!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): AuditLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleteOlderThan"] = this.deleteOlderThan ? this.deleteOlderThan.toISOString() : undefined as any;
        if (Array.isArray(this.logs)) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IAuditLogsDto {
    deleteOlderThan: Date;
    logs: AuditLogDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class AuditLogDto implements IAuditLogDto {
    id!: number;
    event!: string | undefined;
    source!: string | undefined;
    category!: string | undefined;
    subjectIdentifier!: string | undefined;
    subjectName!: string | undefined;
    subjectType!: string | undefined;
    subjectAdditionalData!: string | undefined;
    action!: string | undefined;
    data!: string | undefined;
    created!: Date;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.event = _data["event"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.subjectIdentifier = _data["subjectIdentifier"];
            this.subjectName = _data["subjectName"];
            this.subjectType = _data["subjectType"];
            this.subjectAdditionalData = _data["subjectAdditionalData"];
            this.action = _data["action"];
            this.data = _data["data"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["event"] = this.event;
        data["source"] = this.source;
        data["category"] = this.category;
        data["subjectIdentifier"] = this.subjectIdentifier;
        data["subjectName"] = this.subjectName;
        data["subjectType"] = this.subjectType;
        data["subjectAdditionalData"] = this.subjectAdditionalData;
        data["action"] = this.action;
        data["data"] = this.data;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        return data;
    }
}

export interface IAuditLogDto {
    id: number;
    event: string | undefined;
    source: string | undefined;
    category: string | undefined;
    subjectIdentifier: string | undefined;
    subjectName: string | undefined;
    subjectType: string | undefined;
    subjectAdditionalData: string | undefined;
    action: string | undefined;
    data: string | undefined;
    created: Date;
}

export class PersistedGrantSubjectsApiDto implements IPersistedGrantSubjectsApiDto {
    totalCount!: number;
    pageSize!: number;
    persistedGrants!: PersistedGrantSubjectApiDto[] | undefined;

    constructor(data?: IPersistedGrantSubjectsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["persistedGrants"])) {
                this.persistedGrants = [] as any;
                for (let item of _data["persistedGrants"])
                    this.persistedGrants!.push(PersistedGrantSubjectApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersistedGrantSubjectsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantSubjectsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.persistedGrants)) {
            data["persistedGrants"] = [];
            for (let item of this.persistedGrants)
                data["persistedGrants"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPersistedGrantSubjectsApiDto {
    totalCount: number;
    pageSize: number;
    persistedGrants: PersistedGrantSubjectApiDto[] | undefined;
}

export class PersistedGrantSubjectApiDto implements IPersistedGrantSubjectApiDto {
    id!: number;
    key!: string | undefined;
    type!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    clientId!: string | undefined;
    creationTime!: Date;
    expiration!: Date | undefined;
    data!: string | undefined;
    consumedTime!: Date | undefined;
    sessionId!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPersistedGrantSubjectApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.clientId = _data["clientId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : undefined as any;
            this.data = _data["data"];
            this.consumedTime = _data["consumedTime"] ? new Date(_data["consumedTime"].toString()) : undefined as any;
            this.sessionId = _data["sessionId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PersistedGrantSubjectApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantSubjectApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["type"] = this.type;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["clientId"] = this.clientId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : undefined as any;
        data["data"] = this.data;
        data["consumedTime"] = this.consumedTime ? this.consumedTime.toISOString() : undefined as any;
        data["sessionId"] = this.sessionId;
        data["description"] = this.description;
        return data;
    }
}

export interface IPersistedGrantSubjectApiDto {
    id: number;
    key: string | undefined;
    type: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    clientId: string | undefined;
    creationTime: Date;
    expiration: Date | undefined;
    data: string | undefined;
    consumedTime: Date | undefined;
    sessionId: string | undefined;
    description: string | undefined;
}

export class PersistedGrantApiDto implements IPersistedGrantApiDto {
    id!: number;
    key!: string | undefined;
    type!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    clientId!: string | undefined;
    creationTime!: Date;
    expiration!: Date | undefined;
    data!: string | undefined;
    consumedTime!: Date | undefined;
    sessionId!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPersistedGrantApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.clientId = _data["clientId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : undefined as any;
            this.data = _data["data"];
            this.consumedTime = _data["consumedTime"] ? new Date(_data["consumedTime"].toString()) : undefined as any;
            this.sessionId = _data["sessionId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PersistedGrantApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["type"] = this.type;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["clientId"] = this.clientId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : undefined as any;
        data["data"] = this.data;
        data["consumedTime"] = this.consumedTime ? this.consumedTime.toISOString() : undefined as any;
        data["sessionId"] = this.sessionId;
        data["description"] = this.description;
        return data;
    }
}

export interface IPersistedGrantApiDto {
    id: number;
    key: string | undefined;
    type: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    clientId: string | undefined;
    creationTime: Date;
    expiration: Date | undefined;
    data: string | undefined;
    consumedTime: Date | undefined;
    sessionId: string | undefined;
    description: string | undefined;
}

export class PersistedGrantsApiDto implements IPersistedGrantsApiDto {
    totalCount!: number;
    pageSize!: number;
    persistedGrants!: PersistedGrantApiDto[] | undefined;

    constructor(data?: IPersistedGrantsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["persistedGrants"])) {
                this.persistedGrants = [] as any;
                for (let item of _data["persistedGrants"])
                    this.persistedGrants!.push(PersistedGrantApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersistedGrantsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.persistedGrants)) {
            data["persistedGrants"] = [];
            for (let item of this.persistedGrants)
                data["persistedGrants"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPersistedGrantsApiDto {
    totalCount: number;
    pageSize: number;
    persistedGrants: PersistedGrantApiDto[] | undefined;
}

export class BaseRoleDtoOfString implements IBaseRoleDtoOfString {
    id!: string | undefined;

    constructor(data?: IBaseRoleDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseRoleDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new BaseRoleDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseRoleDtoOfString {
    id: string | undefined;
}

export class RoleDtoOfString extends BaseRoleDtoOfString implements IRoleDtoOfString {
    name!: string;

    constructor(data?: IRoleDtoOfString) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): RoleDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoOfString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IRoleDtoOfString extends IBaseRoleDtoOfString {
    name: string;
}

export class IdentityRoleDto extends RoleDtoOfString implements IIdentityRoleDto {

    constructor(data?: IIdentityRoleDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityRoleDto extends IRoleDtoOfString {
}

export class RolesDtoOfIdentityRoleDtoAndString implements IRolesDtoOfIdentityRoleDtoAndString {
    pageSize!: number;
    totalCount!: number;
    roles!: IdentityRoleDto[] | undefined;

    constructor(data?: IRolesDtoOfIdentityRoleDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolesDtoOfIdentityRoleDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new RolesDtoOfIdentityRoleDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRolesDtoOfIdentityRoleDtoAndString {
    pageSize: number;
    totalCount: number;
    roles: IdentityRoleDto[] | undefined;
}

export class IdentityRolesDto extends RolesDtoOfIdentityRoleDtoAndString implements IIdentityRolesDto {

    constructor(data?: IIdentityRolesDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): IdentityRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRolesDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityRolesDto extends IRolesDtoOfIdentityRoleDtoAndString {
}

export class UsersDtoOfIdentityUserDtoAndString implements IUsersDtoOfIdentityUserDtoAndString {
    pageSize!: number;
    totalCount!: number;
    users!: IdentityUserDto[] | undefined;

    constructor(data?: IUsersDtoOfIdentityUserDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(IdentityUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDtoOfIdentityUserDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDtoOfIdentityUserDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUsersDtoOfIdentityUserDtoAndString {
    pageSize: number;
    totalCount: number;
    users: IdentityUserDto[] | undefined;
}

export class IdentityUsersDto extends UsersDtoOfIdentityUserDtoAndString implements IIdentityUsersDto {

    constructor(data?: IIdentityUsersDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): IdentityUsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUsersDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUsersDto extends IUsersDtoOfIdentityUserDtoAndString {
}

export class BaseUserDtoOfString implements IBaseUserDtoOfString {
    id!: string | undefined;

    constructor(data?: IBaseUserDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseUserDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new BaseUserDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseUserDtoOfString {
    id: string | undefined;
}

export class UserDtoOfString extends BaseUserDtoOfString implements IUserDtoOfString {
    userName!: string;
    email!: string;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    lockoutEnabled!: boolean;
    twoFactorEnabled!: boolean;
    accessFailedCount!: number;
    lockoutEnd!: Date | undefined;

    constructor(data?: IUserDtoOfString) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : undefined as any;
        }
    }

    static override fromJS(data: any): UserDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoOfString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : undefined as any;
        super.toJSON(data);
        return data;
    }
}

export interface IUserDtoOfString extends IBaseUserDtoOfString {
    userName: string;
    email: string;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    lockoutEnabled: boolean;
    twoFactorEnabled: boolean;
    accessFailedCount: number;
    lockoutEnd: Date | undefined;
}

export class IdentityUserDto extends UserDtoOfString implements IIdentityUserDto {

    constructor(data?: IIdentityUserDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUserDto extends IUserDtoOfString {
}

export class RoleClaimsApiDtoOfString implements IRoleClaimsApiDtoOfString {
    claims!: RoleClaimApiDtoOfString[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IRoleClaimsApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(RoleClaimApiDtoOfString.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): RoleClaimsApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimsApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IRoleClaimsApiDtoOfString {
    claims: RoleClaimApiDtoOfString[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class RoleClaimApiDtoOfString implements IRoleClaimApiDtoOfString {
    claimId!: number;
    roleId!: string | undefined;
    claimType!: string;
    claimValue!: string;

    constructor(data?: IRoleClaimApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): RoleClaimApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IRoleClaimApiDtoOfString {
    claimId: number;
    roleId: string | undefined;
    claimType: string;
    claimValue: string;
}

export class UserRolesApiDtoOfIdentityRoleDto implements IUserRolesApiDtoOfIdentityRoleDto {
    roles!: IdentityRoleDto[] | undefined;
    pageSize!: number;
    totalCount!: number;

    constructor(data?: IUserRolesApiDtoOfIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserRolesApiDtoOfIdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesApiDtoOfIdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item ? item.toJSON() : undefined as any);
        }
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IUserRolesApiDtoOfIdentityRoleDto {
    roles: IdentityRoleDto[] | undefined;
    pageSize: number;
    totalCount: number;
}

export class UserRoleApiDtoOfString implements IUserRoleApiDtoOfString {
    userId!: string | undefined;
    roleId!: string | undefined;

    constructor(data?: IUserRoleApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserRoleApiDtoOfString {
    userId: string | undefined;
    roleId: string | undefined;
}

export class UserClaimsApiDtoOfString implements IUserClaimsApiDtoOfString {
    claims!: UserClaimApiDtoOfString[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IUserClaimsApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaimApiDtoOfString.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): UserClaimsApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimsApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IUserClaimsApiDtoOfString {
    claims: UserClaimApiDtoOfString[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class UserClaimApiDtoOfString implements IUserClaimApiDtoOfString {
    claimId!: number;
    userId!: string | undefined;
    claimType!: string;
    claimValue!: string;

    constructor(data?: IUserClaimApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaimApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IUserClaimApiDtoOfString {
    claimId: number;
    userId: string | undefined;
    claimType: string;
    claimValue: string;
}

export class UserProvidersApiDtoOfString implements IUserProvidersApiDtoOfString {
    providers!: UserProviderApiDtoOfString[] | undefined;

    constructor(data?: IUserProvidersApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(UserProviderApiDtoOfString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProvidersApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProvidersApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserProvidersApiDtoOfString {
    providers: UserProviderApiDtoOfString[] | undefined;
}

export class UserProviderApiDtoOfString implements IUserProviderApiDtoOfString {
    userId!: string | undefined;
    userName!: string | undefined;
    providerKey!: string | undefined;
    loginProvider!: string | undefined;
    providerDisplayName!: string | undefined;

    constructor(data?: IUserProviderApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.providerKey = _data["providerKey"];
            this.loginProvider = _data["loginProvider"];
            this.providerDisplayName = _data["providerDisplayName"];
        }
    }

    static fromJS(data: any): UserProviderApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProviderApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["providerKey"] = this.providerKey;
        data["loginProvider"] = this.loginProvider;
        data["providerDisplayName"] = this.providerDisplayName;
        return data;
    }
}

export interface IUserProviderApiDtoOfString {
    userId: string | undefined;
    userName: string | undefined;
    providerKey: string | undefined;
    loginProvider: string | undefined;
    providerDisplayName: string | undefined;
}

export class UserProviderDeleteApiDtoOfString implements IUserProviderDeleteApiDtoOfString {
    userId!: string | undefined;
    providerKey!: string | undefined;
    loginProvider!: string | undefined;

    constructor(data?: IUserProviderDeleteApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.providerKey = _data["providerKey"];
            this.loginProvider = _data["loginProvider"];
        }
    }

    static fromJS(data: any): UserProviderDeleteApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProviderDeleteApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["providerKey"] = this.providerKey;
        data["loginProvider"] = this.loginProvider;
        return data;
    }
}

export interface IUserProviderDeleteApiDtoOfString {
    userId: string | undefined;
    providerKey: string | undefined;
    loginProvider: string | undefined;
}

export class UserChangePasswordApiDtoOfString implements IUserChangePasswordApiDtoOfString {
    userId!: string | undefined;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IUserChangePasswordApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UserChangePasswordApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserChangePasswordApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUserChangePasswordApiDtoOfString {
    userId: string | undefined;
    password: string;
    confirmPassword: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}